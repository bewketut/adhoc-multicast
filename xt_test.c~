

static unsigned int mcast_tg4(const struct sk_buff **pskb,
			      const struct xt_target_param *par)
{
    const struct sk_buff *skb = *pskb;
    const struct iphdr *iph = ip_hdr(skb);
     if(iph==NULL) return NF_ACCEPT;
    if (ipv4_is_multicast(iph->daddr))	//broadcast also mcast so: skb->pkt_type==PACKET_MULTICAST check?? 
    {

	if (ip_hdr(skb)->protocol == IPPROTO_UDP)
	    return mcast_handler4(iph);	//there maybe NF_DROPs
	if (ip_hdr(skb)->protocol == IPPROTO_IGMP)
	    return igmp_handler(iph,skb);	//always NF_ACCEPT just for snooping
    } else if (ip_hdr(skb)->protocol == IPPROTO_UDP) {
	//the heartbeat protocol can be ICMP, or any other so long as we 
        // get its ip header to extract msrc.
	return unicast_handler(iph);	//this needs to make fast construction of <s,c> pair
    }
    return NF_ACCEPT;
}


static struct xt_target mcast_tg_reg __read_mostly = {
    .name = "MCAST",
    .revision = 0,
    .family = NFPROTO_IPV4,
    .target = mcast_tg4,
    .targetsize = XT_ALIGN(0),
    .me = THIS_MODULE,
};

static int __init mcast_tg_init(void)
{

    mgrp_hash = init_table(MGRP_SIZE);
    msrc_hash = init_table(MSRC_SIZE);

    return xt_register_target(&mcast_tg_reg);
}
static void __exit mcast_tg_exit(void)
{
    delete_table(mgrp_hash, MGRP_SIZE);
    delete_table(msrc_hash, MSRC_SIZE);
    xt_unregister_target(&mcast_tg_reg);
}

module_init(mcast_tg_init);
module_exit(mcast_tg_exit);
MODULE_LICENSE("GPL");
MODULE_ALIAS("ipt_MCAST");
MODULE_DESCRIPTION("Xtables: Mcast packet filter");
MODULE_AUTHOR("Bewketu Tadilo<xxxx@xxxx.edu.au>");
