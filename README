what you need
=============
You need iptables >= 1.4.3
and kernel-header >= 2.6.17  (can also use ONLY header files -kernel-headers*.rpm/deb in /lib/modules)
tool: socat, vlc 
main module is xt_mcast.c  
--now updated to work with ping if you don't have socat and to use mcastcmds instead of vlc for testing. 
--Intentional small bug (for it not work) has been removed...
 (copyrighted work)code bug removed and has been made Berlkely license and free
(Give credit to the copyright owner-Bewketu Tadilo (me)- in any further code). 
What it does
============
This module provides a filter for incoming multicast traffic by doing the f/g:
1. Snooping Subscibe (or join) messages and storing the client by its group
hash
2. We also snoop mulitcast source address (unicast type). This is the part where one sort of NEEDs 
to pierce a hole for the multicast (which can be seen in the second last line) source- its unicast address.
We store the client by the multicast source hash.

3. When multicast trafffic come we hash both group and source address and
Checking if the client exists in both hashes.

testing (blocking and unblocking multicast traffic)
===================================================
For testing purpose do the following (need to be root) :
# sh test.sh 
Start vlc (www.videolan.org) stream video  on 238.234.234.1
Start extra vlc. Try to open the video on open network and entering the streamingaddress. It should NOT open.
You will have to choose UDP in both cases.

Then do the following (after changing the 192.x.x.x to your local ip)  
echo "hi" | socat - udp-sendto:192.x.x.x:4444 
and it should now open

sim_test
========
This gives a userland simulator to what the kernel module is trying to do.

related (application level filtering)
==============
on the sender end:
------------------
1. encode with a random byte (random constant) of the beginning of the traffic (constant can be for example filename) to
be sent data before the socket send (part of the the whole data broken by BUF_SIZed socketdata length)
send the constant with start of file or start of data on the socket.
then on every send encode the data as:
thirdbyte=thirdbyte+firstbyte-secondbyte-theconstant
firstbyte=firstbyte+theconstant,
on the receiver end
-------------------
receive the constant with filename and as a start of data.
before decoding thirdbyte hold sum= thirdbyte,then decode thirdbyte= thirdbyte-firstbyte+secondbyte;
if diff= sum - (thirdbyte+firstbyte-secondbyte) is zero, the data is correct
then decode firstbyte= firstbyte-theconstant....then you get data...
if diff is not zero, you filter out the data (application level filtering is complete)
mcastcmds-nt2 (employes the above application level filtering mechanism)
========================
This allows to run commands on remote multicast joined host and importantly multicast file transfers. Who knows maybe this
could be used for android devices..imagine a lecturer using this app sending all "multicast joined" students lecture notes
without "copy from this one student or from the one who has it". I have no new computer and android building tools are
newer and demand 64-bit computers and so I have been kept dumb due to lack of money and resource. The one who gets this
idea can mention me and they should be more than capable to build cleaner application than xrender used in iphones and
androids.

